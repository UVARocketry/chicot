//! This file is for autogenerating a platformio.ini script from the
//! build info provided
const config = @import("config");
const std = @import("std");
const helpers = @import("helpers");
const ZonType = helpers.buildInfo.ZonType;
const zon = @import("zon");
const zonParse = helpers.parseZon;
const inherit = helpers.inherit;

const checkPioPy = @embedFile("checkPio.py");

pub fn getFileContents(
    dir: std.fs.Dir,
    name: []const u8,
    alloc: std.mem.Allocator,
    maxLen: usize,
) ![]const u8 {
    var buf = try alloc.alloc(u8, maxLen);
    errdefer alloc.free(buf);
    const file = try dir.openFile(name, .{});
    var reader = file.reader(&.{});
    const len = try reader.interface.readSliceShort(buf);
    if (len < buf.len) {
        if (alloc.resize(buf, len)) {
            buf = buf[0..len];
        } else {
            const newBuf = try alloc.alloc(u8, buf.len);
            @memcpy(newBuf, buf[0..len]);
            alloc.free(buf);
            buf = newBuf;
        }
    }
    return buf;
}

pub fn main() !void {
    // var cwdBuf: [500]u8 = undefined;

    const allocator = std.heap.smp_allocator;
    var zonParseArena: std.heap.ArenaAllocator = .init(allocator);
    const arena = zonParseArena.allocator();

    var val = zonParse.parseZonStruct(
        arena,
        ZonType,
        zon.buildmodes,
        ".buildmodes",
    );

    try inherit.resolveInheritance(arena, &val);

    var argIterator = try std.process.argsWithAllocator(allocator);
    if (argIterator.next()) |_| {} else {
        return error.NoArgs;
    }
    const name = argIterator.next() orelse return error.NoFileArg;
    const pioCheckPyName = argIterator.next() orelse return error.NoFileArg;
    const pioContents = argIterator.next() orelse return error.NothingToDiff;
    const pioCheckContents = argIterator.next() orelse return error.NothingToDiff;

    var allocatingWriter: std.Io.Writer.Allocating = .init(allocator);
    defer allocatingWriter.deinit();

    const outputFile = try std.fs.createFileAbsolute(name, .{ .truncate = true });
    defer outputFile.close();
    var buf: [1024]u8 = undefined;
    var outWriter = outputFile.writer(&buf);
    const outIow = &allocatingWriter.writer;

    try outIow.print(
        \\; DO NOT EDIT THIS FILE!!!! 
        \\; THIS FILE IS AUTOGENERATED BY THE ZIG BUILD SCRIPT
        \\
        \\; PlatformIO Project Configuration File
        \\;
        \\;   Build options: build flags, source filter
        \\;   Upload options: custom upload port, speed and extra flags
        \\;   Library options: dependencies, extra library storages
        \\;   Advanced options: extra scripting
        \\;
        \\; Please visit documentation for the other options and examples
        \\; https://docs.platformio.org/page/projectconf.html
        \\;
        \\
        \\
    , .{});

    const DependencyInfo = struct {
        name: []const u8,
        url: []const u8,
    };

    var deps: std.ArrayList(DependencyInfo) = .{};
    defer deps.deinit(allocator);

    {
        var mapIter = val.map.iterator();

        // what follows is a very scary nested loop, just follow the comments and
        // you will be fine

        // for all elements in the buildmodes map...
        while (mapIter.next()) |next| {
            // if they have a valid configuration...
            if (next.value_ptr.platformio != null) {
                continue;
            }

            // for all actual dependencies it uses...
            for (next.value_ptr.dependencies) |dep| {
                for (deps.items) |currentDep| {
                    if (std.mem.eql(u8, currentDep.name, dep.dependencyName)) {
                        break;
                    }
                } else {
                    // if we have not yet encountered that dependency...
                    const newDep: DependencyInfo = blk: {
                        // find the dependency we want...
                        inline for (@typeInfo(@TypeOf(zon.dependencies)).@"struct".fields) |f| {
                            if (std.mem.eql(u8, f.name, dep.dependencyName)) {
                                // create a dependency object
                                break :blk .{
                                    .name = f.name,
                                    .url = @field(zon.dependencies, f.name).url,
                                };
                            }
                        }
                        @panic("No depency found!");
                    };
                    // append the dependency to the array
                    try deps.append(allocator, newDep);
                }
            }
        }
    }

    var mapIter = val.map.iterator();

    while (mapIter.next()) |v| {
        if (v.value_ptr.outputTypes.len == 0) {
            continue;
        }
        if (v.value_ptr.*.platformio) |p| {
            try outIow.print("[env:{s}]\n", .{v.key_ptr.*});
            try outIow.print("build_type = {s}\n", .{p.build_type});
            try outIow.print("platform = {s}\n", .{p.platform});
            try outIow.print("framework = {s}\n", .{p.framework});
            try outIow.print("board = {s}\n", .{p.board});
            try outIow.print("lib_deps = ", .{});
            var first = true;
            for (p.lib_deps) |dep| {
                if (!first) {
                    try outIow.writeAll(", ");
                }
                first = false;
                try outIow.print("{s}", .{dep});
            }
            for (deps.items) |dep| {
                if (!first) {
                    try outIow.writeAll(", ");
                }
                first = false;
                try outIow.print("{s}", .{dep.url});
            }
            try outIow.print("\n", .{});

            const actualName = std.fs.path.basename(pioCheckPyName);
            try outIow.print("extra_scripts = pre:{s}", .{actualName});
            for (p.extra_scripts) |s| {
                try outIow.print(", {s}", .{s});
            }
            try outIow.print("\n", .{});

            const cppInfo = v.value_ptr.*.cpp;

            try outIow.print("build_flags =", .{});
            if (cppInfo.define) |def| {
                var iter = def.map.iterator();
                while (iter.next()) |define| {
                    if (define.value_ptr.*) |defineValue| {
                        try outIow.writeAll(" ");
                        try outIow.print("-D{s}", .{define.key_ptr.*});
                        if (defineValue.len != 0) {
                            try outIow.print("={s}", .{defineValue});
                        }
                    }
                }
            }
            for (cppInfo.include) |inc| {
                try outIow.print(" -I{s}", .{inc});
            }
            for (cppInfo.link) |inc| {
                try outIow.print(" -l{s}", .{inc});
            }
            for (cppInfo.otherFlags) |inc| {
                try outIow.print(" {s}", .{inc});
            }
            try outIow.print(" -Lzig-out/lib -lzig", .{});

            try outIow.print("\n", .{});
            try outIow.print("\n", .{});
        }
    }
    // var dir = try std.fs.cwd().openDir(".", .{ .iterate = true });
    // defer dir.close();
    // var iter = dir.iterate();
    // while (try iter.next()) |v| {
    //     try outIow.print("{s}\n", .{v.name});
    // }

    // const currentContents = try getFileContents(dir, name, allocator, 40000);
    // try outIow.print("\nLEN: {}\n\n", .{currentContents.len});
    // defer allocator.free(currentContents);
    // try outIow.writeAll(currentContents);
    // try outIow.writeAll(try std.process.getCwd(&buf));

    try outIow.flush();

    const outWriterIow = &outWriter.interface;
    try outWriterIow.writeAll(
        allocatingWriter.writer.buffer[0..allocatingWriter.writer.end],
    );
    try outWriterIow.flush();

    if (pioContents.len != 0 and !std.mem.eql(
        u8,
        pioContents,
        allocatingWriter.writer.buffer[0..allocatingWriter.writer.end],
    )) {
        std.debug.print("no\n", .{});
        return error.DiffComparisonFailed;
    }

    const outputPy = try std.fs.createFileAbsolute(
        pioCheckPyName,
        .{ .truncate = true },
    );
    defer outputPy.close();
    var pyWriter = outputPy.writer(&buf);
    const pyIow = &pyWriter.interface;
    try pyIow.writeAll(checkPioPy);
    try pyIow.flush();

    if (pioCheckContents.len != 0 and !std.mem.eql(
        u8,
        pioCheckContents,
        checkPioPy,
    )) {
        std.debug.print("no\n", .{});
        return error.DiffComparisonFailed;
    }
}
